# DATAMESH.AI — Minimal A2A Protocol (Day 1)

This document defines the minimal Agent-to-Agent (A2A) protocol for DATAMESH.AI. It leverages the Agent Contract v1 to ensure that delegations are explicit, auditable, and governance-aware from the very first release.

Goals:
- **Deterministic interactions** — no “god” agents, no implicit calls.
- **Traceability** — every hop carries a trace context and audit references.
- **Policy enforcement** — `spec.a2a` + `spec.governance` determine which calls are allowed.
- **Runtime-agnostic** — protocol can be transported via HTTP, gRPC, message bus, etc.
- **Idempotent & secure** — request identifiers, deadlines, and signatures are first-class.

---

## 1) Core Concepts

| Term             | Description                                                                   |
|------------------|-------------------------------------------------------------------------------|
| **Caller Agent** | Agent initiating the request (must be authorized via its own `spec.a2a`).     |
| **Callee Agent** | Agent receiving the request for a capability it exposes.                      |
| **Capability**   | Action being requested (e.g., `catalog.resolve`).                              |
| **Trace**        | Correlation context (`traceId`, `parentSpanId`, `spanId`) propagated end-to-end. |
| **RequestId**    | Unique identifier for idempotency/audit (generated by caller).                |
| **OnBehalfOf**   | Optional user/agent identity when delegation occurs.                          |
| **Deadline**     | Hard execution limit (ms) for the request, propagated downstream.             |
| **Auth Context** | Reference to auth artifacts (mTLS, JWT, signatures) validated per hop.        |

---

## 2) Standard Payload (JSON)

```json
{
  "protocolVersion": "datamesh.ai/a2a/v1",
  "requestId": "req-12345",
  "deadlineMs": 15000,
  "trace": {
    "traceId": "a1b2c3d4...",
    "parentSpanId": "z9y8x7w6...",
    "spanId": "1234abcd"
  },
  "caller": {
    "agent": "sql-agent",
    "capability": "sql.generate"
  },
  "callee": {
    "agent": "catalog-agent",
    "capability": "catalog.resolve"
  },
  "context": {
    "onBehalfOf": {
      "userId": "user-42",
      "roles": ["analyst"],
      "delegationChain": ["sql-agent"]
    },
    "policiesApplied": [
      "policies/rgpd.yaml",
      "policies/data-retention.yaml"
    ],
    "constraints": {
      "maxDepth": 3,
      "currentDepth": 1
    },
    "authContextRef": "mTLS:spiffe://corp/sql-agent",
    "signature": {
      "alg": "ed25519",
      "value": "base64signature=="
    }
  },
  "payloadRef": {
    "inputSchema": "schemas/catalog.resolve.input.json",
    "outputSchema": "schemas/catalog.resolve.output.json",
    "data": {
      "dataset": "catalog://finance.customer_transactions",
      "fields": ["id", "amount", "currency"]
    }
  }
}
```

### Notes
- `requestId` is generated by the caller and reused for retries to ensure idempotency.
- `trace.parentSpanId` follows W3C/OpenTelemetry semantics; required if `requireTraceParent` is true.
- `deadlineMs` is the absolute time budget; callee/orchestrator must enforce or reject if exceeded.
- `context.onBehalfOf` is mandatory only when `allowedOnBehalfOf` is true for the caller.
- `context.signature` is optional but recommended when mutual attestation is required.
- `payloadRef.data` must conform to the referenced schema.

---

## 3) Interaction Phases

1. **REQUEST**  
   Caller sends payload to orchestrator (or directly to callee if topology allows).

2. **ACK**  
   Callee (or orchestrator) responds immediately with a `requestId`, acknowledging receipt and queue placement.

3. **RESPONSE**  
   Callee responds with `status` (`SUCCESS`, `ERROR`, or `IN_PROGRESS` for async), output payload (or `error.details`), and `auditRef`.

### Response Example

```json
{
  "requestId": "req-12345",
  "status": "SUCCESS",
  "trace": {
    "traceId": "a1b2c3d4...",
    "spanId": "abcd9876"
  },
  "output": {
    "schema": "schemas/catalog.resolve.output.json",
    "data": {
      "fields": [
        {"name": "id", "type": "string"},
        {"name": "amount", "type": "decimal(18,2)"},
        {"name": "currency", "type": "string"}
      ]
    }
  },
  "auditRef": "audits/catalog-agent/req-12345.json"
}
```

Async/long-running (`IN_PROGRESS`):

```json
{
  "requestId": "req-12345",
  "status": "IN_PROGRESS",
  "nextPollAfterMs": 2000,
  "trace": {
    "traceId": "a1b2c3d4...",
    "spanId": "abcd9876"
  },
  "auditRef": "audits/catalog-agent/req-12345-stage1.json"
}
```

On `ERROR`:

```json
{
  "requestId": "req-12345",
  "status": "ERROR",
  "error": {
    "code": "FORBIDDEN_CAPABILITY",
    "message": "sql-agent is not authorized to call catalog.lineage",
    "policyRefs": ["policies/rgpd.yaml"]
  },
  "auditRef": "audits/catalog-agent/req-12345-error.json"
}
```

---

## 4) Enforcement Rules

1. **Capability Whitelist**  
   `caller.spec.a2a.canCall` must list the callee `agentRef` *and* requested `capability`. Callee also verifies it actually exposes the capability; mismatch → `FORBIDDEN_CAPABILITY`.

2. **Depth Limiting**  
   `callConstraints.maxDepth` ensures no infinite delegation. `currentDepth` increments per hop. Exceeding the max produces `MAX_DEPTH_EXCEEDED`.

3. **Trace Propagation**  
   `requireTraceParent` forces caller to pass trace metadata. If absent, request fails (`MISSING_TRACE_PARENT`).

4. **Delegation (`onBehalfOf`)**  
   Only allowed when `allowedOnBehalfOf` is true for the caller’s contract. Callee logs delegation chain and may re-check policies.

5. **Policy Binding**  
   `policiesApplied` declares governance rules enforced. Orchestrator and callee cross-check that required policies (from `spec.governance`) are present.

6. **Redaction & Audit**  
   Fields under `spec.observability.audit.redactFields` are masked before logging/forwarding.

7. **Idempotency**  
   `requestId` + `deadlineMs` + `payloadRef` combination must be deduplicated by the callee to avoid replay or double-execution.

8. **Capability Existence**  
   Callee must return `UNKNOWN_CAPABILITY` if the requested capability is not declared in its own `spec.capabilities`.

---

## 5) Sequence Example (SQL Agent → Catalog Agent)

```
User
  │ request monthly schema
  ▼
SQL Agent (Capability: sql.generate)
  │ checks governance + data access
  │ builds payload for catalog.resolve
  ▼
Catalog Agent
  │ validates trace, depth, policies
  │ returns schema metadata
  ▼
SQL Agent
  │ continues workflow with verified metadata
```

Each hop emits telemetry events:

| Span              | Description                              |
|-------------------|------------------------------------------|
| `sql-agent:request`  | User request entering SQL Agent          |
| `sql-agent→catalog-agent` | Outbound A2A call with trace context    |
| `catalog-agent:resolve`   | Resolver span + audit log entry        |
| `catalog-agent→sql-agent` | Response span, includes `auditRef`     |

---

## 6) Transport Recommendations

- **HTTP/HTTPS** with JSON body and mTLS for intra-mesh calls (default).
- **gRPC** for low-latency data centers (supports streaming `IN_PROGRESS` updates).
- **Message bus (Kafka/NATS)** for async or long-running delegations; payloads remain unchanged.

Regardless of transport, the payload structure and enforcement rules stay the same.

---

## 7) Extensibility Hooks

- **Streaming responses** (`status: IN_PROGRESS`) for long tasks with `nextPollAfterMs`.
- **Timeout negotiation** (`deadlineMs` vs callee defaults; callee may return `DEADLINE_REJECTED`).
- **Circuit breakers**: orchestrator can short-circuit if callee is unavailable.
- **Policy overrides**: supervisor agents can attach emergency policies (logged and traceable).
- **Auth upgrades**: optional mutual attestation via signatures or token exchange.

---

## 8) Alignment with Agent Contract

- `spec.a2a` informs **who** can call **whom** and **for what**.
- `spec.capabilities` define the schemas referenced in `payloadRef`.
- `spec.governance` and `spec.observability` directly map to enforcement steps.

This minimal A2A protocol ensures that the Agent Contract v1 is actionable from day one, providing a foundation for secure, traceable, and collaborative agent ecosystems inside DATAMESH.AI while covering idempotency, deadlines, and security hooks expected in enterprise environments.
